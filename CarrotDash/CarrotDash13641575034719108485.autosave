// Game modes
final int GAME_HOME = 0;
final int GAME_RUN = 1;
final int GAME_WIN = 2;
final int GAME_LOSE = 3;

// Speed for grid like movement
final int SPEED = 100;

// Sprites variable
final int SPRITE_SIZE = 100;

// Player variables
PImage[] playerSprites = new PImage[6];
Player p;

// Enemy variables
PImage[][] enemySprites = new PImage[3][2];
ArrayList<Enemy> enemies = new ArrayList<Enemy>();
int enemySpawnInterval;
int lastEnemySpawnTime = 0;

// Item Variables
PImage[] itemSprites = new PImage[3];
ArrayList<Item> items = new ArrayList<Item>();
int itemSpawnInterval = 5000;
int lastItemSpawnTime = 0;

// Grid Variables
Grid grid;

// Game Variables
int gameState = GAME_HOME;
int gameStartTime = 0;
int level = 1;

// Background and UI Images
PImage titleImage;
PImage backgroundImage;

// GridIndicator Variables
ArrayList<GridIndicator> gridIndicators = new ArrayList<GridIndicator>();

void setup() {
  fullScreen();
  loadSprites();
  
  grid = new Grid();
  p = new Player();
  
  frameRate(60);
}

void draw() {
  switch(gameState) {
    case GAME_RUN:
      // Show background image
      if (backgroundImage != null) {
        image(backgroundImage, 0, 0, width, height);
      } else {
        background(50, 150, 50);
      }
      
      if (grid != null) grid.show();

      // gridIndicators
      if (gridIndicators.size() == 0) {
        generateGridIndicators();
      }

      // Spawn enemies every interval - 只生成兩種敵人（移除 gopher）
      if (millis() - lastEnemySpawnTime > enemySpawnInterval) {
        String[] enemyTypes = {"pest", "bird"}; // 移除 "gopher"，只有兩種敵人
        String randomType = enemyTypes[(int)random(enemyTypes.length)];
        
        // 生成怪物在網格外2格的位置
        float spawnX, spawnY;
        
        // 隨機選擇從左或右生成
        boolean fromLeft = random(1) < 0.5;
        
        if (fromLeft) {
          // 從左邊進入，在網格左邊2格外生成
          spawnX = grid.originX - 2 * grid.cellSize;
          // 隨機選擇一個可玩區域的行
          int randomRow = (int)random(1, grid.playableRows + 1); // 1 到 playableRows
          spawnY = grid.originY + randomRow * grid.cellSize;
        } else {
          // 從右邊進入，在網格右邊2格外生成
          spawnX = grid.originX + (grid.cols + 2) * grid.cellSize;
          // 隨機選擇一個可玩區域的行
          int randomRow = (int)random(1, grid.playableRows + 1); // 1 到 playableRows
          spawnY = grid.originY + randomRow * grid.cellSize;
        }
        
        enemies.add(new Enemy(spawnX, spawnY, randomType));
        lastEnemySpawnTime = millis();
        
        println("Spawned " + randomType + " at (" + spawnX + ", " + spawnY + ") from " + (fromLeft ? "left" : "right"));
      }

      // Spawn items - 只生成 flip 和 star
      if (millis() - lastItemSpawnTime > itemSpawnInterval) {
        String[] itemTypes = {"flip", "star"}; // 只有蘑菇和稻草人
        String randomType = itemTypes[(int)random(itemTypes.length)];
        
        // 獲取可用的格子（可玩區域座標）
        ArrayList<PVector> availableCells = getAvailableGridCells();
        
        if (availableCells.size() > 0) {
          // 隨機選擇一個可用的格子
          PVector selectedCell = availableCells.get((int)random(availableCells.size()));
          int playableRow = (int)selectedCell.x; // 可玩區域的相對座標
          int playableCol = (int)selectedCell.y; // 可玩區域的相對座標
          
          // 使用可玩區域座標創建道具
          items.add(new Item(playableRow, playableCol, randomType));
          println("Spawned " + randomType + " at playable(" + playableRow + "," + playableCol + ")");
        }
        
        lastItemSpawnTime = millis();
      }

      // Show player (移除 p.update() 調用)
      if (p != null) p.show();
      
      // Update enemies
      for (int i = enemies.size() - 1; i >= 0; i--) {
        Enemy enemy = enemies.get(i);
        enemy.update();
        enemy.show();
        
        // Check enemy collision with player
        if (enemy.touches(p)) {
          if (!p.isInvincible) {
            p.die();
            gameState = GAME_LOSE;
          }
        }
        
        // 檢查敵人與道具的碰撞
        for (int j = items.size() - 1; j >= 0; j--) {
          Item item = items.get(j);
          if (item.type.equals("flip") && item.touchesEnemy(enemy)) {
            item.applyEffectToEnemy(enemy);
            items.remove(j); // 移除被消耗的蘑菇
            break; // 跳出內層循環，避免索引錯誤
          }
        }
        
        // Remove enemies that are off screen
        if (enemy.isOffScreen()) {
          enemies.remove(i);
        }
      }
      
      // Update items
      for (int i = items.size() - 1; i >= 0; i--) {
        Item item = items.get(i);
        item.update();
        item.show();
        
        // Check item collision with player
        if (item.touches(p)) {
          item.applyEffect(p);
          items.remove(i);
        }
      }
      
      // Update and show gridIndicators
      for (GridIndicator indicator : gridIndicators) {
        indicator.update();
        indicator.show();

        // GridIndicator collision with player
        if (indicator.touches(p)) {
          indicator.applyEffect(p);
        }
      }

      // Check survival time
      int survivalTime = millis() - gameStartTime;
      if (survivalTime >= 60000) {
        gameState = GAME_WIN;
      }

      // Enhanced UI with semi-transparent background for readability
      fill(0, 150);
      noStroke();
      rectMode(CORNER); // 確保 UI 使用正確的矩形模式
      rect(10, 10, 300, 200);
      
      fill(255);
      textSize(32);
      textAlign(LEFT, TOP);
      text("Time: " + (survivalTime / 1000) + "s", 20, 20);
      text("Level: " + level, 20, 60);
      
      // Show player status with colors
      if (p.isFlipped) {
        fill(255, 0, 255);
        text("FLIPPED!", 20, 100);
      }
      if (p.isInvincible) {
        fill(255, 255, 0);
        text("INVINCIBLE!", 20, 140);
      }
      if (p.showGridIndicator) {
        fill(0, 255, 0);
        text("GRID TRACKER!", 20, 180);
      }
      
      // Show enemy count
      fill(0, 150);
      rect(width - 220, 10, 210, 60);
      fill(255, 100, 100);
      textAlign(LEFT, TOP);
      text("Enemies: " + enemies.size(), width - 200, 20);

      break;
      
    case GAME_LOSE:
      loadGameResult("YOU LOST!");
      break;

    case GAME_WIN:
      loadGameResult("YOU WIN!");
      break;

    case GAME_HOME:
      // Clear background first
      background(0);
      
      // Show background image - 修復背景顯示
      if (backgroundImage != null) {
        // 確保背景圖片填滿整個螢幕
        imageMode(CORNER);
        image(backgroundImage, 0, 0, width, height);
      }
      
      // Show title image with proper scaling and positioning
      if (titleImage != null) {
        // Calculate scale to fit within 60% of screen width and 25% of screen height
        float maxTitleWidth = width * 0.6;
        float maxTitleHeight = height * 0.25;
        float titleScale = min(maxTitleWidth / titleImage.width, maxTitleHeight / titleImage.height);
        
        float titleW = titleImage.width * titleScale;
        float titleH = titleImage.height * titleScale;
        
        imageMode(CENTER);
        image(titleImage, width/2, height/2 - 100, titleW, titleH);
      } else {
        // Fallback text title
        fill(255, 140, 0);
        textAlign(CENTER, CENTER);
        textSize(72);
        text("CARROT DASH", width / 2, height / 2 - 100);
      }
      
      // Menu options with better styling and positioning
      fill(0, 180);
      rectMode(CENTER);
      rect(width/2, height/2 + 100, 500, 250);
      
      fill(255);
      textAlign(CENTER, CENTER);
      textSize(36);
      text("Choose a Level", width / 2, height / 2 + 20);
      
      textSize(28);
      text("Press 1 for Level 1 (3x3)", width / 2, height / 2 + 60);
      text("Press 2 for Level 2 (4x4)", width / 2, height / 2 + 100);
      text("Press 3 for Level 3 (5x5)", width / 2, height / 2 + 140);
      
      // Instructions
      textSize(20);
      fill(200);
      text("Use WASD or Arrow Keys to move", width / 2, height / 2 + 180);
      break;

    default:
      background(0);
  }
}

void keyPressed() {
  if (gameState == GAME_RUN && p != null) {
    if (keyCode == UP    || key == 'w' || key == 'W') p.move("UP");
    if (keyCode == DOWN  || key == 's' || key == 'S') p.move("DOWN");
    if (keyCode == LEFT  || key == 'a' || key == 'A') p.move("LEFT");
    if (keyCode == RIGHT || key == 'd' || key == 'D') p.move("RIGHT");
  }

  if (gameState == GAME_HOME) {
    if (key == '1') {
      level = 1;
      startGame();
    } else if (key == '2') {
      level = 2;
      startGame();
    } else if (key == '3') {
      level = 3;
      startGame();
    }
  }

  if (gameState == GAME_LOSE || gameState == GAME_WIN) {
    if (key == 'r' || key == 'R') {
      resetGame();
    }
  }
}

void resetGame() {
  gameState = GAME_HOME;
  enemies.clear();
  items.clear();
  gridIndicators.clear(); // 清空 gridIndicators
  level = 1; // Reset to default level
  grid = new Grid(); // Recreate grid
  p = new Player(); // Recreate player
  lastEnemySpawnTime = millis();
  lastItemSpawnTime = millis();
}

void startGame() {
  println("Starting game with level: " + level); // Debug
  gameState = GAME_RUN;
  
  // 重新建立網格和玩家
  grid = new Grid();
  p = new Player();
  
  enemies.clear();
  items.clear();
  gridIndicators.clear(); // 清空 gridIndicators
  
  lastEnemySpawnTime = millis();
  lastItemSpawnTime = millis();
  gameStartTime = millis();

  // 設定敵人生成間隔 - 可以根據需要調整難度
  if (level == 1) enemySpawnInterval = 4000;  // 第1關：4秒一個敵人（較簡單）
  else if (level == 2) enemySpawnInterval = 3500; // 第2關：3.5秒一個敵人
  else if (level == 3) enemySpawnInterval = 3000; // 第3關：3秒一個敵人（較困難）
  else enemySpawnInterval = 3000; // 預設3秒
}

void loadSprites() {
  // Player sprites - 使用胡蘿蔔圖片
  try {
    playerSprites[0] = loadImage("data/carrotMain.png");    // default
    playerSprites[1] = loadImage("data/carrotUp.png");      // up
    playerSprites[2] = loadImage("data/carrotRight.png");   // right
    playerSprites[3] = loadImage("data/carrotDown.png");    // down
    playerSprites[4] = loadImage("data/carrotLeft.png");    // left
    playerSprites[5] = loadImage("data/carrotMain.png");    // defeated

    // Load UI images
    titleImage = loadImage("data/Title.PNG");
    backgroundImage = loadImage("data/startBG.png");
    
    println("All sprites loaded successfully!");
  } catch (Exception e) {
    println("Error loading sprites: " + e.getMessage());
    // 建立空白圖片作為後備
    for (int i = 0; i < playerSprites.length; i++) {
      playerSprites[i] = createImage(100, 100, RGB);
    }
  }
}

void loadGameResult(String message) {
  // Show background - 修復背景顯示
  if (backgroundImage != null) {
    imageMode(CORNER); // 確保使用角落模式
    image(backgroundImage, 0, 0, width, height);
  } else {
    background(0);
  }
  
  fill(0, 200);
  noStroke();
  rectMode(CENTER);
  rect(width / 2, height / 2, 600, 300);

  fill(255);
  textSize(48);
  textAlign(CENTER, CENTER);
  text(message, width/2, height/2 - 40);
  textSize(24);
  text("Press R to restart", width/2, height/2 + 20);
}

// 新增方法：生成所有的 gridIndicators
void generateGridIndicators() {
  if (grid == null) return;
  
  gridIndicators.clear();
  
  println("=== Generating GridIndicators ===");
  println("Grid size: " + grid.rows + "x" + grid.cols);
  println("Playable size: " + grid.playableRows + "x" + grid.playableCols);
  
  // 生成所有邊界位置的 gridIndicators
  for (int row = 0; row < grid.rows; row++) {
    for (int col = 0; col < grid.cols; col++) {
      if (grid.isGridIndicatorCell(row, col)) {
        GridIndicator indicator = new GridIndicator(row, col);
        gridIndicators.add(indicator);
        println("Generated GridIndicator at (" + row + ", " + col + ")");
      }
    }
  }
  
  println("Total GridIndicators generated: " + gridIndicators.size());
  println("Expected GridIndicators: " + (2 * grid.rows + 2 * grid.cols - 4)); // 邊界格子總數
  println("===============================");
}

// 修正 getAvailableGridCells 方法
ArrayList<PVector> getAvailableGridCells() {
  ArrayList<PVector> availableCells = new ArrayList<PVector>();
  
  if (grid == null) return availableCells;
  
  // 只檢查可玩區域的格子（使用可玩區域的相對座標）
  for (int row = 0; row < grid.playableRows; row++) {
    for (int col = 0; col < grid.playableCols; col++) {
      boolean occupied = false;
      
      // 檢查玩家是否在此格子
      if (p != null) {
        PVector playerPos = p.getCurrentGridPosition();
        if ((int)playerPos.x == row && (int)playerPos.y == col) {
          occupied = true;
        }
      }
      
      // 檢查是否已有道具
      for (Item item : items) {
        if (!item.collected && item.isInPlayableArea()) {
          // 轉換為可玩區域座標進行比較
          int itemPlayableRow = item.gridRow - 1;
          int itemPlayableCol = item.gridCol - 1;
          if (itemPlayableRow == row && itemPlayableCol == col) {
            occupied = true;
            break;
          }
        }
      }
      
      if (!occupied) {
        availableCells.add(new PVector(row, col));
      }
    }
  }
  
  return availableCells;
}

// 可選：新增方法直接在指定網格位置生成道具
void spawnItemAtGridPosition(int row, int col, String itemType) {
  if (grid != null && row >= 0 && row < grid.rows && col >= 0 && col < grid.cols) {
    items.add(new Item(row, col, itemType));
  }
}
