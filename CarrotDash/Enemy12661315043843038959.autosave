class Enemy {
  float x, y, w, h;
  float velocityX; // Only need horizontal movement speed
  String type;        // "pest", "bird"
  PImage[] sprites;   // Store multiple animation frames
  float speed;
  
  // Animation variables
  int animFrame = 0;
  int lastAnimTime = 0;
  int animSpeed = 200; // milliseconds per frame

  Enemy(float startX, float startY, String type) {
    this.x = startX;
    this.y = startY;
    this.type = type;
    this.w = 100;
    this.h = 100;
    
    // Load sprites based on type
    loadSpritesForType(type);
    
    // Set different speeds for different enemy types
    if (type.equals("pest")) {
      speed = 2.0;
      animSpeed = 300;
    }
    else if (type.equals("bird")) {
      speed = 1.5;
      animSpeed = 150;
    }
    else {
      speed = 1.5; // default
      animSpeed = 250;
    }
    
    // Determine movement direction based on spawn position
    setMovementDirection(startX);
    
    println("Enemy " + type + " created at (" + x + ", " + y + ") velocityX: " + velocityX);
  }
  
  void setMovementDirection(float startX) {
    if (grid == null) {
      // If no grid, default to moving right
      velocityX = speed;
      return;
    }
    
    // Calculate grid center position
    float gridCenterX = grid.originX + (grid.cols * grid.cellSize) / 2;
    
    if (startX < gridCenterX) {
      // Spawn from left, move right
      velocityX = speed;
      println("Enemy spawned on LEFT, moving RIGHT with velocity: " + velocityX);
    } else {
      // Spawn from right, move left
      velocityX = -speed;
      println("Enemy spawned on RIGHT, moving LEFT with velocity: " + velocityX);
    }
  }

  // New: reverse movement direction
  void reverseDirection() {
    velocityX = -velocityX;
    println("Enemy " + type + " direction reversed! New velocityX: " + velocityX);
  }
  
  void loadSpritesForType(String enemyType) {
    if (enemyType.equals("pest")) {
      sprites = new PImage[3];
      sprites[0] = loadImage("data/pest1.PNG");
      sprites[1] = loadImage("data/pest2.PNG");
      sprites[2] = loadImage("data/pest3.PNG");
    }
    else if (enemyType.equals("bird")) {
      sprites = new PImage[4];
      sprites[0] = loadImage("data/bird1.png");
      sprites[1] = loadImage("data/bird2.png");
      sprites[2] = loadImage("data/bird3.png");
      sprites[3] = loadImage("data/bird4.png");
    }
    else {
      // Default sprite
      sprites = new PImage[1];
      sprites[0] = loadImage("data/pest1.PNG");
    }
    
    // Check if images loaded successfully
    for (int i = 0; i < sprites.length; i++) {
      if (sprites[i] == null) {
        sprites[i] = createImage(100, 100, RGB);
        sprites[i].loadPixels();
        for (int j = 0; j < sprites[i].pixels.length; j++) {
          sprites[i].pixels[j] = color(255, 0, 0); // Red fallback
        }
        sprites[i].updatePixels();
      }
    }
  }

  void update() {
    // Update animation
    if (millis() - lastAnimTime > animSpeed) {
      animFrame = (animFrame + 1) % sprites.length;
      lastAnimTime = millis();
    }
    
    // Movement logic based on enemy type
    if (type.equals("pest")) {
      // pest simple horizontal linear movement
      x += velocityX;
    } else if (type.equals("bird")) {
      // bird special teleport logic
      updateBirdMovement();
    } else {
      // Default movement
      x += velocityX;
    }
  }
  
  // New: bird special movement logic
  void updateBirdMovement() {
    if (grid == null) {
      x += velocityX;
      return;
    }
    
    // Calculate Grid boundaries
    float gridLeft = grid.originX;
    float gridRight = grid.originX + grid.cols * grid.cellSize;
    
    // Move bird
    x += velocityX;
    
    // Check if hitting Grid boundaries
    if (velocityX > 0) {
      // Moving right, check if hitting left boundary
      if (x + w >= gridLeft && x <= gridLeft) {
        // Teleport to inside Grid on right side
        x = gridRight - w - 20; // A bit inside right boundary
        velocityX = -speed; // Change to moving left
        
        // Remove: no longer select new row, keep same Y coordinate
        println("Bird teleported to RIGHT side, now moving LEFT");
      }
    } else if (velocityX < 0) {
      // Moving left, check if hitting right boundary
      if (x <= gridRight && x + w >= gridRight) {
        // Teleport to inside Grid on left side
        x = gridLeft + 20; // A bit inside left boundary
        velocityX = speed; // Change to moving right
        
        // Remove: no longer select new row, keep same Y coordinate
        println("Bird teleported to LEFT side, now moving RIGHT");
      }
    }
  }

  void show() {
    pushMatrix();
    translate(x + w/2, y + h/2);
    
    // Fix image flip logic
    if (type.equals("pest")) {
      // pest flip logic
      if (velocityX > 0) {
        scale(-1, 1); // Flip when moving right
      }
    } else if (type.equals("bird")) {
      // bird flip logic
      if (velocityX < 0) {
        scale(-1, 1); // Flip when moving left
      }
    }
    
    // Add visual effects based on type
    if (type.equals("bird")) {
      // Bird has slight transparency and floating effect (remove flicker)
      tint(255, 230);
      // Slight up-down floating
      translate(0, sin(frameCount * 0.1) * 5);
    } else if (type.equals("pest")) {
      // pest keep fully opaque
      noTint();
    } else {
      noTint();
    }
    
    imageMode(CENTER);
    if (sprites != null && animFrame < sprites.length && sprites[animFrame] != null) {
      image(sprites[animFrame], 0, 0, w, h);
    } else {
      // Fallback display
      if (type.equals("pest")) {
        fill(255, 0, 0); // pest red
      } else if (type.equals("bird")) {
        fill(0, 0, 255); // bird blue
      } else {
        fill(255, 0, 0); // default red
      }
      ellipse(0, 0, w, h);
    }
    
    noTint();
    popMatrix();
    
    // Debug: show enemy position and speed
    if (keyPressed && key == 'd') {
      fill(255, 255, 0);
      textAlign(CENTER, CENTER);
      textSize(10);
      text(type + " (" + (int)x + "," + (int)y + ") vX:" + velocityX, x + w/2, y - 15);
      
      // Show flip status and position status
      String status = "";
      if (type.equals("bird")) {
        if (x < grid.originX) status = "OUTSIDE-L";
        else if (x > grid.originX + grid.cols * grid.cellSize) status = "OUTSIDE-R";
        else status = "INSIDE";
      }
      fill(255, 100, 100);
      text(status, x + w/2, y + h + 5);
    }
  }

  boolean touches(Player p) {
    // Collision detection
    return p.isAlive && dist(x + w/2, y + h/2, p.x + p.w/2, p.y + p.h/2) < (w + p.w) * 0.4;
  }
  
  boolean isOffScreen() {
    if (type.equals("bird")) {
      // bird won't truly leave screen because it teleports
      return false;
    }
    
    // pest allow moving off map, only remove when completely off screen
    return x < -200 || x > width + 200;
  }
}
