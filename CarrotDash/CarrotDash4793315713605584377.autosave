// Game modes
final int GAME_HOME = 0;
final int GAME_RUN = 1;
final int GAME_WIN = 2;
final int GAME_LOSE = 3;

// Speed for grid like movement
final int SPEED = 100;

// Sprites variable
final int SPRITE_SIZE = 100;

// Player variables
PImage[] playerSprites = new PImage[6];
Player p;

// Enemy variables
PImage[][] enemySprites = new PImage[3][2];
ArrayList<Enemy> enemies = new ArrayList<Enemy>();
int enemySpawnInterval;
int lastEnemySpawnTime = 0;

// Item Variables
PImage[] itemSprites = new PImage[3];
ArrayList<Item> items = new ArrayList<Item>();
int itemSpawnInterval = 5000;
int lastItemSpawnTime = 0;

// Grid Variables
Grid grid;

// Game Variables
int gameState = GAME_HOME;
int gameStartTime = 0;
int level = 1; // Set default value

// Background and UI Images
PImage titleImage;
PImage backgroundImage;

// GridIndicator Variables
ArrayList<GridIndicator> gridIndicators = new ArrayList<GridIndicator>();

void setup() {
  //size(1600, 900);
  fullScreen();
  loadSprites();
  
  // Initialize grid and player when level is already set
  grid = new Grid();
  p = new Player();
  
  frameRate(60);
}

void draw() {
  switch(gameState) {
    case GAME_RUN:
      // Show background image
      if (backgroundImage != null) {
        image(backgroundImage, 0, 0, width, height);
      } else {
        background(50, 150, 50);
      }
      
      if (grid != null) grid.show();

      // Generate gridIndicators (once at game start)
      if (gridIndicators.size() == 0) {
        generateGridIndicators();
      }

      // Spawn enemies every interval - restrict enemy types by level
      if (millis() - lastEnemySpawnTime > enemySpawnInterval) {
        String[] enemyTypes;
        
        // Define enemy types based on level
        if (level == 1) {
          enemyTypes = new String[]{"pest"}; 
        } else if (level == 2) {
          enemyTypes = new String[]{"pest", "bird"}; 
        } else if (level == 3) {
          enemyTypes = new String[]{"pest", "bird"}; 
        } else {
          enemyTypes = new String[]{"pest"};
        }
        
        String randomType = enemyTypes[(int)random(enemyTypes.length)];
        
        // Generate monsters at 2 grids outside the grid
        float spawnX, spawnY;
        
        // Randomly choose to spawn from left or right
        boolean fromLeft = random(1) < 0.5;
        
        if (fromLeft) {
          // Enter from left, spawn 2 grids outside left edge
          spawnX = grid.originX - 2 * grid.cellSize;
          // Randomly select a row in playable area
          int randomRow = (int)random(1, grid.playableRows + 1); // 1 to playableRows
          spawnY = grid.originY + randomRow * grid.cellSize;
        } else {
          // Enter from right, spawn 2 grids outside right edge
          spawnX = grid.originX + (grid.cols + 2) * grid.cellSize;
          // Randomly select a row in playable area
          int randomRow = (int)random(1, grid.playableRows + 1); // 1 to playableRows
          spawnY = grid.originY + randomRow * grid.cellSize;
        }
        
        enemies.add(new Enemy(spawnX, spawnY, randomType));
        lastEnemySpawnTime = millis();
        
        println("Spawned " + randomType + " at (" + spawnX + ", " + spawnY + ") from " + (fromLeft ? "left" : "right"));
      }

      // Spawn items - restrict item types by level
      if (millis() - lastItemSpawnTime > itemSpawnInterval) {
        String[] itemTypes;
        
        // Define item types based on level
        if (level == 1) {
          itemTypes = new String[]{}; 
        } else if (level == 2) {
          itemTypes = new String[]{};
        } else if (level == 3) {
          itemTypes = new String[]{"flip", "star"}; 
        } else {
          itemTypes = new String[]{};
        }
        
        // Only spawn items if there are item types available for this level
        if (itemTypes.length > 0) {
          String randomType = itemTypes[(int)random(itemTypes.length)];
          
          // Get available cells (playable area coordinates)
          ArrayList<PVector> availableCells = getAvailableGridCells();
          
          if (availableCells.size() > 0) {
            // Randomly select an available cell
            PVector selectedCell = availableCells.get((int)random(availableCells.size()));
            int playableRow = (int)selectedCell.x; 
            int playableCol = (int)selectedCell.y; 
            
            // Create item using playable area coordinates
            items.add(new Item(playableRow, playableCol, randomType));
            println("Spawned " + randomType + " at playable(" + playableRow + "," + playableCol + ")");
          }
        }
        
        lastItemSpawnTime = millis();
      }

      // Show player
      if (p != null) p.show();
      
      // Update enemies
      for (int i = enemies.size() - 1; i >= 0; i--) {
        Enemy enemy = enemies.get(i);
        enemy.update();
        enemy.show();
        
        // Check enemy collision with player
        if (enemy.touches(p)) {
          if (!p.isInvincible) {
            p.die();
            gameState = GAME_LOSE;
          }
        }
        
        // Check enemy collision with items (only if items exist)
        if (level >= 3) { // Only check item collisions in level 3+
          for (int j = items.size() - 1; j >= 0; j--) {
            Item item = items.get(j);
            if (item.type.equals("flip") && item.touchesEnemy(enemy)) {
              item.applyEffectToEnemy(enemy);
              items.remove(j); // Remove consumed mushroom
              break; // Exit inner loop to avoid index error
            }
          }
        }
        
        // Remove enemies that are off screen
        if (enemy.isOffScreen()) {
          enemies.remove(i);
        }
      }
      
      // Update items (only if items exist)
      if (level >= 3) { // Only update items in level 3+
        for (int i = items.size() - 1; i >= 0; i--) {
          Item item = items.get(i);
          item.update();
          item.show();
          
          // Check item collision with player
          if (item.touches(p)) {
            item.applyEffect(p);
            items.remove(i);
          }
        }
      }
      
      // Update and show gridIndicators (gopher effect available in all levels)
      for (GridIndicator indicator : gridIndicators) {
        indicator.update();
        indicator.show();

        // GridIndicator collision with player
        if (indicator.touches(p)) {
          indicator.applyEffect(p);
        }
      }

      // Check survival time
      int survivalTime = millis() - gameStartTime;
      if (survivalTime >= 60000) {
        gameState = GAME_WIN;
      }

      // UI
      fill(0, 150);
      noStroke();
      rectMode(CORNER); 
      rect(10, 10, 300, 240); 
      
      fill(255);
      textSize(32);
      textAlign(LEFT, TOP);
      text("Time: " + (survivalTime / 1000) + "s", 20, 20);
      text("Level: " + level, 20, 60);
      
      // Show level features
      textSize(16);
      fill(200, 200, 255);
      text("Level " + level + " Features:", 20, 100);
      
      if (level == 1) {
        text("• Pest enemies", 20, 120);
        text("• Gopher (GridIndicator)", 20, 140);
      } else if (level == 2) {
        text("• Pest enemies", 20, 120);
        text("• Bird enemies (teleport)", 20, 140);
        text("• Gopher (GridIndicator)", 20, 160);
      } else if (level == 3) {
        text("• Pest enemies", 20, 120);
        text("• Bird enemies (teleport)", 20, 140);
        text("• Gopher (GridIndicator)", 20, 160);
        text("• Scarecrow (invincibility)", 20, 180);
        text("• Poison Mushroom (flip)", 20, 200);
      }
      
      // Show player status
      fill(255);
      if (p.isFlipped) {
        fill(255, 0, 255);
        text("FLIPPED!", 320, 120);
      }
      if (p.isInvincible) {
        fill(255, 255, 0);
        text("INVINCIBLE!", 320, 140);
      }
      if (p.showGridIndicator) {
        fill(0, 255, 0);
        text("GRID TRACKER!", 320, 160);
      }
      
      // Show enemy count
      fill(0, 150);
      rect(width - 220, 10, 210, 60);
      fill(255, 100, 100);
      textAlign(LEFT, TOP);
      text("Enemies: " + enemies.size(), width - 200, 20);

      break;
      
    case GAME_LOSE:
      loadGameResult("YOU LOST!");
      break;

    case GAME_WIN:
      loadGameResult("YOU WIN!");
      break;

    case GAME_HOME:
      // Clear background first
      background(0);
      
      // Show background image - fix background display
      if (backgroundImage != null) {
        // Ensure background image fills entire screen
        imageMode(CORNER);
        image(backgroundImage, 0, 0, width, height);
      }
      
      // Show title image with proper scaling and positioning
      if (titleImage != null) {
        // Calculate scale to fit within 60% of screen width and 25% of screen height
        float maxTitleWidth = width * 0.6;
        float maxTitleHeight = height * 0.25;
        float titleScale = min(maxTitleWidth / titleImage.width, maxTitleHeight / titleImage.height);
        
        float titleW = titleImage.width * titleScale;
        float titleH = titleImage.height * titleScale;
        
        imageMode(CENTER);
        image(titleImage, width/2, height/2 - 100, titleW, titleH);
      } else {
        // Fallback text title
        fill(255, 140, 0);
        textAlign(CENTER, CENTER);
        textSize(72);
        text("CARROT DASH", width / 2, height / 2 - 100);
      }
      
      // Menu options with better styling and positioning
      fill(0, 180);
      rectMode(CENTER);
      rect(width/2, height/2 + 100, 500, 250);
      
      fill(255);
      textAlign(CENTER, CENTER);
      textSize(36);
      text("Choose a Level", width / 2, height / 2 + 20);
      
      textSize(28);
      text("Press 1 for Level 1 (3x3)", width / 2, height / 2 + 60);
      text("Press 2 for Level 2 (4x4)", width / 2, height / 2 + 100);
      text("Press 3 for Level 3 (5x5)", width / 2, height / 2 + 140);
      
      // Instructions
      textSize(20);
      fill(200);
      text("Use WASD or Arrow Keys to move", width / 2, height / 2 + 180);
      break;

    default:
      background(0);
  }
}

void keyPressed() {
  if (gameState == GAME_RUN && p != null) {
    if (keyCode == UP    || key == 'w' || key == 'W') p.move("UP");
    if (keyCode == DOWN  || key == 's' || key == 'S') p.move("DOWN");
    if (keyCode == LEFT  || key == 'a' || key == 'A') p.move("LEFT");
    if (keyCode == RIGHT || key == 'd' || key == 'D') p.move("RIGHT");
  }

  if (gameState == GAME_HOME) {
    if (key == '1') {
      level = 1;
      startGame();
    } else if (key == '2') {
      level = 2;
      startGame();
    } else if (key == '3') {
      level = 3;
      startGame();
    }
  }

  if (gameState == GAME_LOSE || gameState == GAME_WIN) {
    if (key == 'r' || key == 'R') {
      resetGame();
    }
  }
}

void resetGame() {
  gameState = GAME_HOME;
  enemies.clear();
  items.clear();
  gridIndicators.clear(); // Clear gridIndicators
  level = 1; // Reset to default level
  grid = new Grid(); // Recreate grid
  p = new Player(); // Recreate player
  lastEnemySpawnTime = millis();
  lastItemSpawnTime = millis();
}

void startGame() {
  println("Starting game with level: " + level); // Debug
  gameState = GAME_RUN;
  
  // Recreate grid and player
  grid = new Grid();
  p = new Player();
  
  enemies.clear();
  items.clear();
  gridIndicators.clear(); // Clear gridIndicators
  
  lastEnemySpawnTime = millis();
  lastItemSpawnTime = millis();
  gameStartTime = millis();

  // Set enemy spawn interval based on level and complexity
  if (level == 1) {
    enemySpawnInterval = 5000;  // Level 1: 5 seconds (easier, only pest)
  } else if (level == 2) {
    enemySpawnInterval = 4000;  // Level 2: 4 seconds (pest + bird)
  } else if (level == 3) {
    enemySpawnInterval = 3000;  // Level 3: 3 seconds (all enemies + items)
  } else {
    enemySpawnInterval = 4000;  // Default 4 seconds
  }
  
  // Set item spawn interval (only relevant for level 3+)
  if (level >= 3) {
    itemSpawnInterval = 6000; // 6 seconds for items in level 3
  } else {
    itemSpawnInterval = 999999; // Very long interval (effectively disabled) for levels 1-2
  }
  
  println("Level " + level + " configuration:");
  println("  Enemy spawn interval: " + enemySpawnInterval + "ms");
  println("  Item spawn interval: " + itemSpawnInterval + "ms");
}

void loadSprites() {
  // Player sprites - use carrot images
  try {
    playerSprites[0] = loadImage("data/carrotMain.png");    // default
    playerSprites[1] = loadImage("data/carrotUp.png");      // up
    playerSprites[2] = loadImage("data/carrotRight.png");   // right
    playerSprites[3] = loadImage("data/carrotDown.png");    // down
    playerSprites[4] = loadImage("data/carrotLeft.png");    // left
    playerSprites[5] = loadImage("data/carrotMain.png");    // defeated

    // Load UI images
    titleImage = loadImage("data/Title.PNG");
    backgroundImage = loadImage("data/startBG.png");
    
    println("All sprites loaded successfully!");
  } catch (Exception e) {
    println("Error loading sprites: " + e.getMessage());
    // Create blank images as fallback
    for (int i = 0; i < playerSprites.length; i++) {
      playerSprites[i] = createImage(100, 100, RGB);
    }
  }
}

void loadGameResult(String message) {
  // Show background - fix background display
  if (backgroundImage != null) {
    imageMode(CORNER); // Ensure using corner mode
    image(backgroundImage, 0, 0, width, height);
  } else {
    background(0);
  }
  
  fill(0, 200);
  noStroke();
  rectMode(CENTER);
  rect(width / 2, height / 2, 600, 300);

  fill(255);
  textSize(48);
  textAlign(CENTER, CENTER);
  text(message, width/2, height/2 - 40);
  textSize(24);
  text("Press R to restart", width/2, height/2 + 20);
}

// New method: generate all gridIndicators
void generateGridIndicators() {
  if (grid == null) return;
  
  gridIndicators.clear();
  
  println("=== Generating GridIndicators ===");
  println("Grid size: " + grid.rows + "x" + grid.cols);
  println("Playable size: " + grid.playableRows + "x" + grid.playableCols);
  
  // Generate gridIndicators at all border positions
  for (int row = 0; row < grid.rows; row++) {
    for (int col = 0; col < grid.cols; col++) {
      if (grid.isGridIndicatorCell(row, col)) {
        GridIndicator indicator = new GridIndicator(row, col);
        gridIndicators.add(indicator);
        println("Generated GridIndicator at (" + row + ", " + col + ")");
      }
    }
  }
  
  println("Total GridIndicators generated: " + gridIndicators.size());
  println("Expected GridIndicators: " + (2 * grid.rows + 2 * grid.cols - 4)); // Total border cells
  println("===============================");
}

// Fix getAvailableGridCells method
ArrayList<PVector> getAvailableGridCells() {
  ArrayList<PVector> availableCells = new ArrayList<PVector>();
  
  if (grid == null) return availableCells;
  
  // Only check playable area cells (using playable area relative coordinates)
  for (int row = 0; row < grid.playableRows; row++) {
    for (int col = 0; col < grid.playableCols; col++) {
      boolean occupied = false;
      
      // Check if player is in this cell
      if (p != null) {
        PVector playerPos = p.getCurrentGridPosition();
        if ((int)playerPos.x == row && (int)playerPos.y == col) {
          occupied = true;
        }
      }
      
      // Check if there's already an item
      for (Item item : items) {
        if (!item.collected && item.isInPlayableArea()) {
          // Convert to playable area coordinates for comparison
          int itemPlayableRow = item.gridRow - 1;
          int itemPlayableCol = item.gridCol - 1;
          if (itemPlayableRow == row && itemPlayableCol == col) {
            occupied = true;
            break;
          }
        }
      }
      
      if (!occupied) {
        availableCells.add(new PVector(row, col));
      }
    }
  }
  
  return availableCells;
}

// Optional: new method to directly spawn items at specified grid position
void spawnItemAtGridPosition(int row, int col, String itemType) {
  if (grid != null && row >= 0 && row < grid.rows && col >= 0 && col < grid.cols) {
    items.add(new Item(row, col, itemType));
  }
}
